# GitNetDisk 后端开发文档

## 1. 项目概述
**GitNetDisk** 是一个 GitHub 网盘式可视化工具，后端主要负责：
- GitHub API 代理服务
- 处理文件上传/下载
- 管理用户认证状态
- 提供代理配置服务

## 2. 技术选型

| 分类 | 技术 | 版本 | 选型理由 |
|------|------|------|----------|
| **语言** | TypeScript | 5.0+ | 类型安全，与前端技术栈一致 |
| **运行环境** | Node.js | 18.0+ | 跨平台，生态丰富 |
| **部署平台** | Vercel Serverless | - | 免费、简单、支持边缘部署 |
| **HTTP 客户端** | Axios | 1.0+ | 功能强大，支持代理 |
| **代理支持** | https-proxy-agent | 7.0+ | 支持 HTTP 和 SOCKS5 代理 |
| **认证** | OAuth 2.0 | - | 标准 GitHub 认证流程 |
| **存储** | GitHub API | - | 利用 GitHub 作为存储后端 |

## 3. 系统架构

### 3.1 架构图
```
┌───────────────┐       ┌───────────────┐       ┌───────────────┐
│               │       │               │       │               │
│ 前端应用      │──────▶│ 后端代理服务  │──────▶│ GitHub API    │
│ (React + TS)  │◀──────│ (Vercel      │◀──────│               │
│               │       │ Serverless)  │       │               │
└───────────────┘       └───────────────┘       └───────────────┘
```

### 3.2 核心模块

| 模块名称 | 主要职责 | 文件位置 |
|---------|---------|----------|
| **代理服务** | 转发 GitHub API 请求，支持代理配置 | api/proxy.ts |
| **认证处理** | 处理 OAuth 回调，管理 token | src/lib/github.ts |
| **文件操作** | 文件上传、下载、删除等操作 | src/lib/github.ts |
| **代理工具** | 封装代理请求逻辑 | src/lib/proxy-fetch.ts |

## 4. 目录结构

```
git-net-disk/
├── api/                     # Vercel Serverless 函数
│   ├── proxy.ts            # GitHub API 代理服务
│   └── middleware/         # 中间件
│       ├── index.ts        # 中间件导出
│       ├── cors.ts         # CORS 中间件
│       ├── response.ts     # 统一响应中间件
│       ├── error-handler.ts # 错误处理中间件
│       ├── logger.ts       # 日志中间件
│       └── request-id.ts   # 请求 ID 生成
├── src/
│   ├── lib/                # 核心逻辑库
│   │   ├── github.ts       # GitHub API 封装
│   │   └── proxy-fetch.ts  # 代理请求工具
│   ├── components/         # 前端组件
│   ├── pages/              # 前端页面
│   └── store/              # 状态管理
├── package.json
├── tsconfig.json
└── vercel.json             # Vercel 配置
```

## 5. 核心功能实现

### 5.1 API 规范

**API 设计原则**：
- **RESTful 风格**：使用标准 HTTP 方法
- **统一响应格式**：所有接口返回相同结构
- **版本管理**：支持 API 版本控制
- **错误处理**：统一的错误码和错误信息
- **请求验证**：严格的参数验证

**HTTP 方法规范**：
| 方法 | 用途 | 示例 |
|------|------|------|
| **GET** | 获取资源 | `/api/proxy?target=...` |
| **POST** | 创建资源 | `/api/auth/login` |
| **PUT** | 更新资源 | `/api/files/{path}` |
| **DELETE** | 删除资源 | `/api/files/{path}` |
| **OPTIONS** | 预检请求 | 自动处理 CORS |

**响应格式规范**：

**成功响应**：
```json
{
  "code": 200,
  "success": true,
  "message": "操作成功",
  "data": {
    // 业务数据
  },
  "timestamp": 1768904348,
  "requestId": "uuid-v4"
}
```

**错误响应**：
```json
{
  "code": 400,
  "success": false,
  "message": "错误信息",
  "details": {
    // 错误详情
  },
  "timestamp": 1768904348,
  "requestId": "uuid-v4"
}
```

**错误码规范**：
| 错误码 | 含义 | HTTP 状态码 |
|--------|------|-------------|
| **200** | 成功 | 200 |
| **400** | 请求参数错误 | 400 |
| **401** | 未授权 | 401 |
| **403** | 禁止访问 | 403 |
| **404** | 资源不存在 | 404 |
| **405** | 方法不允许 | 405 |
| **429** | 请求过于频繁 | 429 |
| **500** | 服务器内部错误 | 500 |
| **502** | 代理服务错误 | 502 |
| **504** | 代理超时 | 504 |

**请求头规范**：
| 请求头 | 说明 | 示例 |
|--------|------|------|
| **Content-Type** | 请求体类型 | `application/json` |
| **Authorization** | 认证令牌 | `Bearer <token>` |
| **X-API-Version** | API 版本 | `1.0` |
| **X-Proxy-URL** | 代理配置 | `http://127.0.0.1:7890` |

**响应头规范**：
| 响应头 | 说明 | 示例 |
|--------|------|------|
| **Content-Type** | 响应体类型 | `application/json; charset=utf-8` |
| **X-Powered-By** | 服务标识 | `GitNetDisk` |
| **X-Response-Time** | 响应时间 | `123ms` |
| **X-Request-Id** | 请求 ID | `uuid-v4` |
| **Access-Control-* | CORS 配置 | 见 CORS 中间件 |

### 5.2 中间件规范

**中间件结构**：
```typescript
// api/middleware/
// ├── cors.ts          # CORS 中间件
// ├── error-handler.ts # 错误处理中间件
// ├── logger.ts        # 日志中间件
// ├── response.ts      # 统一响应中间件
// └── request-id.ts    # 请求 ID 生成
```

**CORS 中间件**（api/middleware/cors.ts）：
```typescript
import type { VercelRequest, VercelResponse, VercelMiddleware } from '@vercel/node';

export const corsMiddleware: VercelMiddleware = (req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, x-proxy-url');
  res.setHeader('Access-Control-Max-Age', '86400');
  
  if (req.method === 'OPTIONS') {
    return res.status(204).end();
  }
  
  next();
};
```

**统一响应中间件**（api/middleware/response.ts）：
```typescript
import type { VercelRequest, VercelResponse } from '@vercel/node';

declare global {
  namespace Express {
    interface Response {
      success: <T>(data: T, message?: string) => void;
      error: (code: number, message: string, details?: any) => void;
      setHeaders: () => void;
    }
  }
}

export const responseMiddleware = (req: VercelRequest, res: VercelResponse, next: () => void) => {
  const requestId = (req as any).requestId || 'unknown';
  
  // 统一响应方法
  res.success = function<T>(data: T, message?: string) {
    this.setHeaders();
    return this.status(200).json({
      code: 200,
      success: true,
      message: message || '操作成功',
      data,
      timestamp: Date.now(),
      requestId,
    });
  };
  
  res.error = function(code: number, message: string, details?: any) {
    this.setHeaders();
    return this.status(code).json({
      code,
      success: false,
      message,
      details,
      timestamp: Date.now(),
      requestId,
    });
  };
  
  // 统一设置响应头
  res.setHeaders = function() {
    this.setHeader('Content-Type', 'application/json; charset=utf-8');
    this.setHeader('X-Powered-By', 'GitNetDisk');
    this.setHeader('X-Response-Time', Date.now().toString());
    this.setHeader('X-Request-Id', requestId);
  };
  
  next();
};
```

**错误处理中间件**（api/middleware/error-handler.ts）：
```typescript
import type { VercelRequest, VercelResponse, VercelMiddleware } from '@vercel/node';

export const errorHandlerMiddleware: VercelMiddleware = (req: VercelRequest, res: VercelResponse, next: () => void) => {
  try {
    next();
  } catch (error: any) {
    const requestId = (req as any).requestId || 'unknown';
    console.error(`[${requestId}] 全局错误:`, error);
    
    res.setHeaders();
    res.status(500).json({
      code: 500,
      success: false,
      message: '服务器内部错误',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined,
      timestamp: Date.now(),
      requestId,
    });
  }
};
```

**请求 ID 中间件**（api/middleware/request-id.ts）：
```typescript
import type { VercelRequest, VercelResponse, VercelMiddleware } from '@vercel/node';
import { v4 as uuidv4 } from 'uuid';

declare global {
  namespace Express {
    interface Request {
      requestId: string;
    }
  }
}

export const requestIdMiddleware: VercelMiddleware = (req: VercelRequest, res: VercelResponse, next: () => void) => {
  const requestId = uuidv4();
  (req as any).requestId = requestId;
  res.setHeader('X-Request-Id', requestId);
  next();
};
```

**中间件导出**（api/middleware/index.ts）：
```typescript
export * from './cors';
export * from './response';
export * from './error-handler';
export * from './logger';
export * from './request-id';
```

**日志中间件**（api/middleware/logger.ts）：
```typescript
import type { VercelRequest, VercelResponse, VercelMiddleware } from '@vercel/node';

export const loggerMiddleware: VercelMiddleware = (req: VercelRequest, res: VercelResponse, next: () => void) => {
  const startTime = Date.now();
  const requestId = (req as any).requestId || 'unknown';
  
  console.log(`[${new Date().toISOString()}] [${requestId}] ${req.method} ${req.url}`);
  
  const originalEnd = res.end;
  res.end = function(...args) {
    const endTime = Date.now();
    const responseTime = endTime - startTime;
    
    console.log(`[${new Date().toISOString()}] [${requestId}] ${req.method} ${req.url} ${res.statusCode} ${responseTime}ms`);
    
    return originalEnd.apply(this, args);
  };
  
  next();
};
```

### 5.2 代理服务（api/proxy.ts）

**功能**：
- 转发 GitHub API 请求
- 支持 HTTP/SOCKS5 代理
- 处理 CORS 和错误
- 安全验证目标 URL
- 统一响应格式

**实现代码**：
```typescript
import type { VercelRequest, VercelResponse } from '@vercel/node';
import axios from 'axios';
import httpsProxyAgent from 'https-proxy-agent';
import { corsMiddleware, responseMiddleware, loggerMiddleware, requestIdMiddleware } from './middleware';

// 中间件组合
const applyMiddleware = (req: VercelRequest, res: VercelResponse, next: () => void) => {
  corsMiddleware(req, res, () => {
    requestIdMiddleware(req, res, () => {
      responseMiddleware(req, res, () => {
        loggerMiddleware(req, res, next);
      });
    });
  });
};

export default async function handler(req: VercelRequest, res: VercelResponse) {
  applyMiddleware(req, res, async () => {
    try {
      const { target } = req.query;
      const proxy = req.headers['x-proxy-url'] as string | undefined;
      
      // 安全验证
      if (!target || typeof target !== 'string') {
        return res.error(400, '缺少目标地址');
      }
      
      const url = decodeURIComponent(target);
      
      // 只允许 GitHub API
      if (!url.startsWith('https://api.github.com')) {
        return res.error(403, '只允许 GitHub API 请求');
      }
      
      const config: any = {
        url,
        method: req.method,
        headers: {
          ...req.headers,
          host: 'api.github.com',
          'user-agent': 'GitNetDisk/1.0',
        },
        data: req.body,
        timeout: 30000,
      };
      
      // 配置代理
      if (proxy) {
        config.httpsAgent = new httpsProxyAgent(proxy);
        config.httpAgent = new httpsProxyAgent(proxy);
      }
      
      const response = await axios(config);
      
      // 转发 GitHub API 的响应头
      Object.entries(response.headers).forEach(([key, value]) => {
        if (key !== 'content-length' && key !== 'content-encoding') {
          res.setHeader(key, value as string);
        }
      });
      
      res.setHeaders();
      res.status(response.status).json(response.data);
      
    } catch (error: any) {
      console.error('代理错误:', error);
      
      const statusCode = error.response?.status || 500;
      const message = error.message || '代理服务错误';
      const details = error.response?.data || undefined;
      
      res.error(statusCode, message, details);
    }
  });
}
```

### 5.3 GitHub API 封装（src/lib/github.ts）

**功能**：
- Octokit 实例创建
- 支持代理配置
- 文件操作 API 封装
- 仓库管理 API 封装

**实现代码**：
```typescript
import { Octokit } from '@octokit/core';
import { useProxyStore } from '@/store';

export function getOctokit(token: string) {
  const proxy = useProxyStore.getState().proxyUrl;
  
  if (!proxy) {
    // 直连模式
    return new Octokit({ auth: token });
  }
  
  // 代理模式
  return new Octokit({
    auth: token,
    request: {
      fetch: async (input: RequestInfo | URL, init?: RequestInit) => {
        const url = typeof input === 'string' ? input : input.url;
        const target = encodeURIComponent(url);
        const proxyUrl = `/api/proxy?target=${target}`;
        
        return fetch(proxyUrl, {
          ...init,
          headers: {
            ...init?.headers,
            'x-proxy-url': proxy,
          },
        });
      },
    },
  });
}

// 文件操作封装
export class GitHubFileManager {
  private octokit: Octokit;
  
  constructor(token: string) {
    this.octokit = getOctokit(token);
  }
  
  // 获取文件列表
  async getFiles(owner: string, repo: string, path: string = '') {
    const response = await this.octokit.request(
      'GET /repos/{owner}/{repo}/contents/{path}',
      {
        owner,
        repo,
        path,
      }
    );
    return response.data;
  }
  
  // 上传文件
  async uploadFile(owner: string, repo: string, path: string, content: string | ArrayBuffer, message: string = 'Upload file') {
    const contentBase64 = typeof content === 'string' 
      ? btoa(unescape(encodeURIComponent(content)))
      : Buffer.from(content).toString('base64');
    
    try {
      // 尝试获取文件信息（检查是否存在）
      const existing = await this.octokit.request(
        'GET /repos/{owner}/{repo}/contents/{path}',
        { owner, repo, path }
      );
      
      // 更新文件
      return await this.octokit.request(
        'PUT /repos/{owner}/{repo}/contents/{path}',
        {
          owner,
          repo,
          path,
          message,
          content: contentBase64,
          sha: existing.data.sha,
        }
      );
    } catch (error) {
      // 文件不存在，创建新文件
      return await this.octokit.request(
        'PUT /repos/{owner}/{repo}/contents/{path}',
        {
          owner,
          repo,
          path,
          message,
          content: contentBase64,
        }
      );
    }
  }
  
  // 删除文件
  async deleteFile(owner: string, repo: string, path: string, sha: string, message: string = 'Delete file') {
    return await this.octokit.request(
      'DELETE /repos/{owner}/{repo}/contents/{path}',
      {
        owner,
        repo,
        path,
        message,
        sha,
      }
    );
  }
}

// 仓库管理封装
export class GitHubRepoManager {
  private octokit: Octokit;
  
  constructor(token: string) {
    this.octokit = getOctokit(token);
  }
  
  // 获取用户仓库列表
  async getUserRepos() {
    const response = await this.octokit.request('GET /user/repos', {
      per_page: 100,
      sort: 'updated',
    });
    return response.data;
  }
  
  // 创建新仓库
  async createRepo(name: string, description: string = '', private: boolean = false) {
    const response = await this.octokit.request('POST /user/repos', {
      name,
      description,
      private,
      auto_init: true,
      gitignore_template: 'Node',
    });
    return response.data;
  }
}
```

### 5.4 代理请求工具（src/lib/proxy-fetch.ts）

**功能**：
- 封装代理请求逻辑
- 支持 HTTP 和 SOCKS5 代理
- 错误处理和重试机制

**实现代码**：
```typescript
import axios from 'axios';
import httpsProxyAgent from 'https-proxy-agent';

export interface ProxyFetchOptions {
  proxyUrl?: string;
  timeout?: number;
  headers?: Record<string, string>;
}

export class ProxyFetch {
  private proxyUrl?: string;
  private timeout: number;
  
  constructor(options: ProxyFetchOptions = {}) {
    this.proxyUrl = options.proxyUrl;
    this.timeout = options.timeout || 30000;
  }
  
  async fetch(url: string, options: RequestInit = {}) {
    const config: any = {
      url,
      method: options.method || 'GET',
      headers: {
        ...options.headers,
        'user-agent': 'GitNetDisk/1.0',
      },
      timeout: this.timeout,
    };
    
    if (options.body) {
      config.data = options.body;
    }
    
    if (this.proxyUrl) {
      config.httpsAgent = new httpsProxyAgent(this.proxyUrl);
      config.httpAgent = new httpsProxyAgent(this.proxyUrl);
    }
    
    try {
      const response = await axios(config);
      return new Response(JSON.stringify(response.data), {
        status: response.status,
        headers: response.headers,
      });
    } catch (error: any) {
      console.error('Proxy fetch error:', error);
      throw new Error(error.message || 'Proxy fetch failed');
    }
  }
  
  // 设置代理
  setProxy(proxyUrl?: string) {
    this.proxyUrl = proxyUrl;
  }
}
```

## 6. 认证流程

### 6.1 OAuth 认证流程

```mermaid
sequenceDiagram
    participant User as 用户
    participant Frontend as 前端应用
    participant GitHub as GitHub
    participant Backend as 后端服务

    User->>Frontend: 点击登录
    Frontend->>GitHub: 跳转授权页
    GitHub->>User: 显示授权界面
    User->>GitHub: 授权访问
    GitHub->>Frontend: 重定向到回调页
    Frontend->>Backend: 处理回调，获取 token
    Backend->>Frontend: 返回 token
    Frontend->>Frontend: 存储 token 到本地存储
    Frontend->>User: 登录成功，显示主界面
```

### 6.2 Token 管理

- **存储方式**：localStorage / sessionStorage
- **存储键**：`git-net-disk-token`
- **过期处理**：GitHub token 无固定过期时间，但可能被用户撤销
- **刷新机制**：当 API 调用返回 401 时，提示用户重新登录

## 7. 代理配置

### 7.1 代理类型支持

| 代理类型 | 格式示例 | 支持状态 |
|---------|---------|----------|
| **HTTP 代理** | http://127.0.0.1:7890 | ✅ 支持 |
| **HTTPS 代理** | https://127.0.0.1:7890 | ✅ 支持 |
| **SOCKS5 代理** | socks5://127.0.0.1:1080 | ✅ 支持 |
| **带认证代理** | http://user:pass@proxy.example.com:8080 | ✅ 支持 |

### 7.2 代理检测

**健康检查**：
```typescript
// 检测代理是否可用
async function checkProxy(proxyUrl: string): Promise<boolean> {
  try {
    const proxyFetch = new ProxyFetch({ proxyUrl, timeout: 10000 });
    const response = await proxyFetch.fetch('https://api.github.com/rate_limit');
    return response.ok;
  } catch {
    return false;
  }
}
```

## 8. 部署配置

### 8.1 Vercel 配置

**vercel.json**：
```json
{
  "version": 2,
  "builds": [
    {
      "src": "api/*.ts",
      "use": "@vercel/node"
    },
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": {
        "distDir": "dist"
      }
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "/api/$1"
    },
    {
      "src": "/(.*)",
      "dest": "/index.html"
    }
  ]
}
```

### 8.2 环境变量

| 变量名 | 类型 | 说明 | 必填 |
|-------|------|------|------|
| `NODE_ENV` | string | 运行环境 | 否 |
| `VERCEL` | boolean | 是否在 Vercel 上运行 | 否 |

### 8.3 依赖配置

**package.json**（后端部分）：
```json
{
  "dependencies": {
    "@octokit/core": "^5.0.0",
    "@vercel/node": "^3.0.0",
    "axios": "^1.6.0",
    "https-proxy-agent": "^7.0.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/uuid": "^9.0.0",
    "typescript": "^5.0.0"
  }
}
```

## 9. 性能优化

### 9.1 优化策略

| 优化项 | 策略 | 实现方式 |
|--------|------|----------|
| **请求缓存** | 缓存文件列表 | 前端 localStorage 缓存 |
| **并发控制** | 限制同时上传文件数 | 队列管理 |
| **重试机制** | 网络错误自动重试 | 指数退避算法 |
| **超时设置** | 合理的请求超时 | 30秒超时 |
| **错误处理** | 友好的错误提示 | 分类错误处理 |

### 9.2 监控与日志

**日志记录**：
- 关键操作日志
- 错误日志
- 性能指标

**监控指标**：
- API 响应时间
- 成功率
- 错误率
- 代理状态

## 10. 安全考虑

### 10.1 安全措施

| 安全项 | 措施 | 实现方式 |
|--------|------|----------|
| **URL 验证** | 只允许 GitHub API 请求 | 白名单验证 |
| **CORS 配置** | 限制跨域请求 | Vercel 自动处理 |
| **Token 安全** | 不在后端存储 token | 前端本地存储 |
| **代理安全** | 不记录代理配置 | 内存中临时使用 |
| **输入验证** | 验证用户输入 | 前端验证 + 后端验证 |

### 10.2 风险评估

| 风险 | 等级 | 缓解措施 |
|------|------|----------|
| **GitHub API 限流** | 中 | 缓存策略 + 重试机制 |
| **代理服务故障** | 低 | 自动切换到直连模式 |
| **Token 泄露** | 高 | 前端加密存储 + 定期提醒 |
| **文件上传大小限制** | 中 | GitHub API 限制（100MB） |

## 11. 开发与测试

### 11.1 本地开发

**启动开发服务器**：
```bash
# 前端开发
npm run dev

# 本地测试代理（需要 Vercel CLI）
vercel dev
```

**测试账号**：
- GitHub 测试账号
- 已创建的 OAuth App

### 11.2 测试策略

| 测试类型 | 范围 | 工具 |
|---------|------|------|
| **单元测试** | 核心工具函数 | Jest |
| **集成测试** | API 调用 | Supertest |
| **端到端测试** | 完整流程 | Cypress |
| **性能测试** | 上传下载速度 | 自定义脚本 |

### 11.3 测试用例

**代理服务测试**：
- 正常代理请求
- 无效目标 URL
- 代理连接失败
- 超时处理

**文件操作测试**：
- 上传小文件
- 上传大文件（接近 100MB）
- 删除文件
- 目录浏览

**认证测试**：
- 正常登录流程
- Token 过期处理
- 权限不足处理

## 12. 部署与发布

### 12.1 部署流程

1. **代码准备**
   - 确保所有依赖已安装
   - 运行构建测试

2. **Vercel 部署**
   - 连接 GitHub 仓库
   - 配置构建命令：`npm run build`
   - 配置输出目录：`dist`

3. **环境配置**
   - 无需特殊环境变量
   - 自动配置 Vercel Serverless 函数

4. **验证部署**
   - 访问部署 URL
   - 测试所有功能
   - 验证代理服务

### 12.2 发布版本

| 版本 | 功能 | 发布时间 |
|------|------|----------|
| v1.0.0 | MVP 核心功能 | 2026-02 |
| v1.1.0 | 文件夹上传支持 | 2026-03 |
| v1.2.0 | 批量操作功能 | 2026-04 |
| v2.0.0 | 高级搜索功能 | 2026-06 |

## 13. 维护与支持

### 13.1 常见问题

| 问题 | 可能原因 | 解决方案 |
|------|---------|----------|
| **GitHub 访问失败** | 网络问题或代理配置错误 | 检查代理设置，尝试不同代理 |
| **文件上传失败** | 文件过大或权限不足 | 检查文件大小，确保有写入权限 |
| **Token 无效** | Token 被撤销或过期 | 重新登录获取新 token |
| **代理连接超时** | 代理服务器故障 | 更换代理或使用直连模式 |

### 13.2 技术支持

- **文档**：项目 README 和 API 文档
- **Issue 跟踪**：GitHub Issues
- **社区支持**：Discord 或 Slack 社区
- **联系邮箱**：support@gitnetdisk.com

## 14. 总结

GitNetDisk 后端服务采用 **Vercel Serverless** 架构，具有以下优势：

1. **简单部署**：Vercel 一键部署，无需服务器管理
2. **高效代理**：解决国内 GitHub 访问问题
3. **安全可靠**：标准 OAuth 流程，Token 本地存储
4. **扩展性强**：模块化设计，易于添加新功能
5. **成本效益**：Vercel 免费额度足够个人使用

后端服务与前端紧密配合，共同为用户提供流畅的 GitHub 网盘体验。通过合理的架构设计和性能优化，确保系统稳定运行，同时保持代码的可维护性和可扩展性。
